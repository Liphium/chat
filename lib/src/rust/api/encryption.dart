// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Generate a new random symmetric key.
Future<SymmetricKey> generateSymmetricKey() =>
    RustLib.instance.api.crateApiEncryptionGenerateSymmetricKey();

/// Encrypt a message with a symmetric key.
Future<Uint8List?> encryptSymmetric({
  required SymmetricKey key,
  required List<int> message,
}) => RustLib.instance.api.crateApiEncryptionEncryptSymmetric(
  key: key,
  message: message,
);

/// Decrypt a message with a symmetric key.
Future<Uint8List?> decryptSymmetric({
  required SymmetricKey key,
  required List<int> ciphertext,
}) => RustLib.instance.api.crateApiEncryptionDecryptSymmetric(
  key: key,
  ciphertext: ciphertext,
);

/// Encrypt using a symmetric container
Future<Uint8List?> encryptSymmetricContainer({
  required SymmetricKey key,
  required SigningKey signingKey,
  required List<int> message,
  Uint8List? salt,
}) => RustLib.instance.api.crateApiEncryptionEncryptSymmetricContainer(
  key: key,
  signingKey: signingKey,
  message: message,
  salt: salt,
);

/// Decrypt a symmetric container
Future<Uint8List?> decryptSymmetricContainer({
  required SymmetricKey key,
  required VerifyingKey verifyingKey,
  required List<int> ciphertext,
  Uint8List? salt,
}) => RustLib.instance.api.crateApiEncryptionDecryptSymmetricContainer(
  key: key,
  verifyingKey: verifyingKey,
  ciphertext: ciphertext,
  salt: salt,
);

/// Generate a new signature key pair.
Future<SignatureKeyPair> generateSignatureKeypair() =>
    RustLib.instance.api.crateApiEncryptionGenerateSignatureKeypair();

/// Generate a new asymmetric key pair (public/secret).
Future<AsymmetricKeyPair> generateAsymmetricKeypair() =>
    RustLib.instance.api.crateApiEncryptionGenerateAsymmetricKeypair();

/// Encrypt using an asymmetric container
Future<Uint8List?> encryptAsymmetricContainer({
  required PublicKey publicKey,
  required SigningKey signingKey,
  required List<int> message,
  Uint8List? salt,
}) => RustLib.instance.api.crateApiEncryptionEncryptAsymmetricContainer(
  publicKey: publicKey,
  signingKey: signingKey,
  message: message,
  salt: salt,
);

/// Decrypt an asymmetric container
Future<Uint8List?> decryptAsymmetricContainer({
  required SecretKey secretKey,
  required VerifyingKey verifyingKey,
  required List<int> ciphertext,
  Uint8List? salt,
}) => RustLib.instance.api.crateApiEncryptionDecryptAsymmetricContainer(
  secretKey: secretKey,
  verifyingKey: verifyingKey,
  ciphertext: ciphertext,
  salt: salt,
);

/// Encode a symmetric key.
Future<Uint8List?> encodeSymmetricKey({required SymmetricKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeSymmetricKey(key: key);

/// Encode and drop a symmetric key from the underlying hash map.
Future<Uint8List?> encodeAndDropSymmetricKey({required SymmetricKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeAndDropSymmetricKey(key: key);

/// Decode a symmetric key from bytes.
Future<SymmetricKey?> decodeSymmetricKey({required List<int> data}) =>
    RustLib.instance.api.crateApiEncryptionDecodeSymmetricKey(data: data);

/// Encode a signing key.
Future<Uint8List?> encodeSigningKey({required SigningKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeSigningKey(key: key);

/// Encode and drop a signing key from the underlying hash map.
Future<Uint8List?> encodeAndDropSigningKey({required SigningKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeAndDropSigningKey(key: key);

/// Decode a signing key from bytes.
Future<SigningKey?> decodeSigningKey({required List<int> data}) =>
    RustLib.instance.api.crateApiEncryptionDecodeSigningKey(data: data);

/// Encode a verifying key.
Future<Uint8List?> encodeVerifyingKey({required VerifyingKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeVerifyingKey(key: key);

/// Encode and drop a verifying key from the underlying hash map.
Future<Uint8List?> encodeAndDropVerifyingKey({required VerifyingKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeAndDropVerifyingKey(key: key);

/// Decode a verifying key from bytes.
Future<VerifyingKey?> decodeVerifyingKey({required List<int> data}) =>
    RustLib.instance.api.crateApiEncryptionDecodeVerifyingKey(data: data);

/// Encode a public key.
Future<Uint8List?> encodePublicKey({required PublicKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodePublicKey(key: key);

/// Encode and drop a public key from the underlying hash map.
Future<Uint8List?> encodeAndDropPublicKey({required PublicKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeAndDropPublicKey(key: key);

/// Decode a public key from bytes.
Future<PublicKey?> decodePublicKey({required List<int> data}) =>
    RustLib.instance.api.crateApiEncryptionDecodePublicKey(data: data);

/// Encode a secret key.
Future<Uint8List?> encodeSecretKey({required SecretKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeSecretKey(key: key);

/// Encode and drop a secret key from the underlying hash map.
Future<Uint8List?> encodeAndDropSecretKey({required SecretKey key}) =>
    RustLib.instance.api.crateApiEncryptionEncodeAndDropSecretKey(key: key);

/// Decode a secret key from bytes.
Future<SecretKey?> decodeSecretKey({required List<int> data}) =>
    RustLib.instance.api.crateApiEncryptionDecodeSecretKey(data: data);

class AsymmetricKeyPair {
  final PublicKey publicKey;
  final SecretKey secretKey;

  const AsymmetricKeyPair({required this.publicKey, required this.secretKey});

  @override
  int get hashCode => publicKey.hashCode ^ secretKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AsymmetricKeyPair &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          secretKey == other.secretKey;
}

class PublicKey {
  final int id;

  const PublicKey({required this.id});

  @override
  int get hashCode => id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicKey && runtimeType == other.runtimeType && id == other.id;
}

class SecretKey {
  final int id;

  const SecretKey({required this.id});

  @override
  int get hashCode => id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecretKey && runtimeType == other.runtimeType && id == other.id;
}

class SignatureKeyPair {
  final SigningKey signingKey;
  final VerifyingKey verifyingKey;

  const SignatureKeyPair({
    required this.signingKey,
    required this.verifyingKey,
  });

  @override
  int get hashCode => signingKey.hashCode ^ verifyingKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SignatureKeyPair &&
          runtimeType == other.runtimeType &&
          signingKey == other.signingKey &&
          verifyingKey == other.verifyingKey;
}

class SigningKey {
  final int id;

  const SigningKey({required this.id});

  @override
  int get hashCode => id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SigningKey && runtimeType == other.runtimeType && id == other.id;
}

class SymmetricKey {
  final int id;

  const SymmetricKey({required this.id});

  @override
  int get hashCode => id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SymmetricKey &&
          runtimeType == other.runtimeType &&
          id == other.id;
}

class VerifyingKey {
  final int id;

  const VerifyingKey({required this.id});

  @override
  int get hashCode => id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VerifyingKey &&
          runtimeType == other.runtimeType &&
          id == other.id;
}
