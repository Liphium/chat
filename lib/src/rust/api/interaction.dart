// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.38.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are not used by any `pub` functions: `OutputDevice`

Stream<LogEntry> createLogStream() =>
    RustLib.instance.api.crateApiInteractionCreateLogStream();

Stream<Action> createActionStream() =>
    RustLib.instance.api.crateApiInteractionCreateActionStream();

Future<void> startTalkingEngine() =>
    RustLib.instance.api.crateApiInteractionStartTalkingEngine();

Future<void> testVoice({required String device, required int detectionMode}) =>
    RustLib.instance.api.crateApiInteractionTestVoice(
        device: device, detectionMode: detectionMode);

Future<void> stop() => RustLib.instance.api.crateApiInteractionStop();

Future<void> setAmplitudeLogging({required bool amplitudeLogging}) => RustLib
    .instance.api
    .crateApiInteractionSetAmplitudeLogging(amplitudeLogging: amplitudeLogging);

Future<bool> isAmplitudeLogging() =>
    RustLib.instance.api.crateApiInteractionIsAmplitudeLogging();

Future<void> setTalkingAmplitude({required double amplitude}) =>
    RustLib.instance.api
        .crateApiInteractionSetTalkingAmplitude(amplitude: amplitude);

Future<double> getTalkingAmplitude() =>
    RustLib.instance.api.crateApiInteractionGetTalkingAmplitude();

Stream<double> createAmplitudeStream() =>
    RustLib.instance.api.crateApiInteractionCreateAmplitudeStream();

Future<void> deleteAmplitudeStream() =>
    RustLib.instance.api.crateApiInteractionDeleteAmplitudeStream();

Future<void> setDetectionMode({required int detectionMode}) =>
    RustLib.instance.api
        .crateApiInteractionSetDetectionMode(detectionMode: detectionMode);

Future<int> getDetectionMode() =>
    RustLib.instance.api.crateApiInteractionGetDetectionMode();

Future<List<InputDevice>> listInputDevices() =>
    RustLib.instance.api.crateApiInteractionListInputDevices();

Future<String> getDefaultId() =>
    RustLib.instance.api.crateApiInteractionGetDefaultId();

Future<void> setInputDevice({required String id}) =>
    RustLib.instance.api.crateApiInteractionSetInputDevice(id: id);

Future<void> setOutputDevice({required String id}) =>
    RustLib.instance.api.crateApiInteractionSetOutputDevice(id: id);

class Action {
  final String action;
  final String data;

  const Action({
    required this.action,
    required this.data,
  });

  @override
  int get hashCode => action.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Action &&
          runtimeType == other.runtimeType &&
          action == other.action &&
          data == other.data;
}

class InputDevice {
  final String id;
  final String displayName;
  final int sampleRate;
  final bool bestQuality;

  const InputDevice({
    required this.id,
    required this.displayName,
    required this.sampleRate,
    required this.bestQuality,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      displayName.hashCode ^
      sampleRate.hashCode ^
      bestQuality.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InputDevice &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          displayName == other.displayName &&
          sampleRate == other.sampleRate &&
          bestQuality == other.bestQuality;
}

class LogEntry {
  final PlatformInt64 timeSecs;
  final String tag;
  final String msg;

  const LogEntry({
    required this.timeSecs,
    required this.tag,
    required this.msg,
  });

  @override
  int get hashCode => timeSecs.hashCode ^ tag.hashCode ^ msg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogEntry &&
          runtimeType == other.runtimeType &&
          timeSecs == other.timeSecs &&
          tag == other.tag &&
          msg == other.msg;
}
